# HTTP Adapter Operations Guide

This guide covers the complete end-to-end operational process for all HTTP-type adapters in Integrix Flow Bridge, including HTTP, HTTPS, REST, and SOAP sender adapters.

## Table of Contents
1. [Overview](#overview)
2. [Adapter Types and Their Purposes](#adapter-types-and-their-purposes)
3. [Endpoint URL Architecture](#endpoint-url-architecture)
4. [Configuration Process](#configuration-process)
5. [Operational Modes](#operational-modes)
6. [End-to-End Flow Examples](#end-to-end-flow-examples)
7. [Troubleshooting](#troubleshooting)

## Overview

**CRITICAL**: Remember the reversed terminology in this system:
- **Sender Adapter** = Receives data FROM external systems (inbound in traditional terms)
- **Receiver Adapter** = Sends data TO external systems (outbound in traditional terms)

## Adapter Types and Their Purposes

### 1. HTTP/HTTPS Sender Adapters
- **Purpose**: Generic HTTP endpoint for receiving data via HTTP/HTTPS protocols
- **Use Cases**: Webhooks, form submissions, generic HTTP integrations
- **Formats**: Any content type (JSON, XML, plain text, binary)

### 2. REST Sender Adapters
- **Purpose**: RESTful API endpoints with enhanced REST features
- **Use Cases**: Modern API integrations, microservices communication
- **Formats**: Primarily JSON/XML with content negotiation

### 3. SOAP Sender Adapters
- **Purpose**: SOAP web service endpoints for enterprise integrations
- **Use Cases**: Legacy system integration, enterprise B2B communication
- **Formats**: SOAP envelopes with XML payloads

## Endpoint URL Architecture

### Two Types of Endpoints

All HTTP-type sender adapters work with TWO distinct endpoint concepts:

#### 1. **Inbound Endpoints** (System-Generated)
Where external systems send data TO your adapter:

```
Pattern: http(s)://[your-server]:[port]/api/inbound/webhook/{adapterId}

Examples:
- HTTP:  http://localhost:8080/api/inbound/webhook/http-adapter-001
- REST:  http://localhost:8080/api/inbound/webhook/rest-adapter-002
- SOAP:  http://localhost:8080/api/inbound/webhook/soap-adapter-003
```

**Key Points:**
- Automatically generated by the system
- Uses the adapter's unique ID in the URL path
- Cannot be customized by users
- Always follows the same pattern regardless of adapter type

#### 2. **Outbound Endpoints** (User-Configured)
Where your adapter fetches data FROM (polling mode):

```yaml
endpointUrl: "https://external-api.com/data"  # External system to poll
```

**Key Points:**
- Configured by users in adapter settings
- Only used when polling is enabled
- Points to external systems
- Has no relationship to the inbound endpoint URL

## Configuration Process

### Step 1: Create the Adapter

Navigate to **Communication Adapters** → **Create New**

#### HTTP Adapter Example:
```yaml
Basic Information:
  Name: "Customer Updates HTTP Receiver"
  Type: HTTP
  Direction: Sender  # Receives FROM external systems
  Description: "Receives customer update notifications"

Connection Configuration:
  # For POLLING mode (optional)
  endpointUrl: "https://api.external-system.com/customer-updates"
  
  # For WEBHOOK mode (leave endpointUrl empty)
  # System will generate: /api/inbound/webhook/{adapterId}

Authentication:
  Type: Bearer Token
  Token: ${env.API_TOKEN}

Request Configuration:
  Method: POST  # Method adapter uses for polling
  Content-Type: application/json
  Accept: application/json

Polling Configuration:
  Enabled: true  # Set to false for webhook-only mode
  Interval: 300000  # 5 minutes
  
Error Handling:
  Retry Count: 3
  Retry Delay: 5000
  On Error: Log and Continue
```

#### REST Adapter Example:
```yaml
Basic Information:
  Name: "Order REST API Receiver"
  Type: REST
  Direction: Sender

Connection Configuration:
  # For polling from external REST API
  endpointUrl: "https://orders.api.com/v2/new-orders"
  
  # Additional REST features
  apiVersion: "2.0"
  resourcePath: "/orders"
  
Authentication:
  Type: OAuth2
  Access Token: ${env.OAUTH_TOKEN}
  Token URL: "https://auth.api.com/token"
  
Pagination:
  Enabled: true
  Page Size: 100
  Page Parameter: "page"
  
Rate Limiting:
  Max Requests Per Minute: 60
```

#### SOAP Adapter Example:
```yaml
Basic Information:
  Name: "ERP SOAP Service Receiver"
  Type: SOAP
  Direction: Sender

Connection Configuration:
  # For polling SOAP service
  endpointUrl: "https://erp.company.com/soap/CustomerService"
  wsdlUrl: "https://erp.company.com/soap/CustomerService?wsdl"
  
Service Configuration:
  Service Name: "CustomerUpdateService"
  Port Name: "CustomerUpdatePort"
  Operation: "GetUpdatedCustomers"
  
Authentication:
  Type: WS-Security
  Username: ${env.SOAP_USER}
  Password: ${env.SOAP_PASS}
  
SSL Configuration:
  Enable SSL: true
  Trust Store: /path/to/truststore.jks
  Trust Store Password: ${env.TRUST_PASS}
```

### Step 2: Understand Generated Endpoints

After creating the adapter, the system generates:

```
Adapter ID: cust-http-adapter-a1b2c3d4

Generated Inbound Endpoint:
http://your-server:8080/api/inbound/webhook/cust-http-adapter-a1b2c3d4

This is where external systems should send data TO your adapter.
```

### Step 3: Configure External Systems

#### For Webhook Mode:
Provide the generated endpoint to external systems:
```
Webhook URL: http://your-server:8080/api/inbound/webhook/cust-http-adapter-a1b2c3d4
Method: POST
Headers:
  - Content-Type: application/json
  - Authorization: Bearer your-token-here
```

#### For Polling Mode:
No external configuration needed - your adapter will poll the configured `endpointUrl`.

## Operational Modes

### 1. Webhook Mode (Passive)

**Configuration:**
```yaml
Polling:
  Enabled: false
  
# endpointUrl not needed
```

**How it works:**
1. External system sends HTTP request to generated endpoint
2. Adapter receives and processes the request
3. Data flows through integration pipeline
4. Response sent back to external system

**Flow Diagram:**
```
External System → POST → /api/inbound/webhook/{adapterId} → Adapter → Integration Flow
                                                              ↓
                                            Response ← Processing Complete
```

### 2. Polling Mode (Active)

**Configuration:**
```yaml
endpointUrl: "https://api.external.com/updates"
Polling:
  Enabled: true
  Interval: 60000  # 1 minute
```

**How it works:**
1. Adapter polls external endpoint every interval
2. Fetches new/updated data
3. Processes through integration pipeline
4. Tracks last poll timestamp for incremental updates

**Flow Diagram:**
```
Adapter → GET/POST → https://api.external.com/updates → External System
   ↑                                                           ↓
   └─────────── Every 60 seconds ←───── Response Data ────────┘
                        ↓
                Integration Flow
```

### 3. Hybrid Mode (Both)

**Configuration:**
```yaml
endpointUrl: "https://api.external.com/updates"
Polling:
  Enabled: true
  Interval: 300000  # 5 minutes
```

**How it works:**
- Accepts webhooks at generated endpoint
- Also polls external system periodically
- Useful for systems that support both push and pull

**Flow Diagram:**
```
Webhook:  External → POST → /api/inbound/webhook/{adapterId} → Processing
                                                                     ↓
Polling:  Adapter → GET → https://api.external.com/updates ────────→ ↓
             ↑                                                       ↓
             └────────── Every 5 minutes ←──────────────────────────┘
                                    ↓
                            Integration Flow
```

## End-to-End Flow Examples

### Example 1: REST API Webhook Integration

**Scenario**: Receive order notifications from e-commerce platform

**1. Create REST Sender Adapter:**
```yaml
Name: "Shopify Order Webhook"
Type: REST
Direction: Sender
Polling: 
  Enabled: false
Authentication:
  Type: HMAC
  Secret: ${env.SHOPIFY_WEBHOOK_SECRET}
```

**2. Generated Endpoint:**
```
http://integration.company.com/api/inbound/webhook/shopify-order-webhook-x7y8z9
```

**3. Configure in Shopify:**
```
Webhook URL: http://integration.company.com/api/inbound/webhook/shopify-order-webhook-x7y8z9
Events: Order Created, Order Updated
```

**4. Operation Flow:**
```
1. Customer places order in Shopify
2. Shopify sends POST request to webhook endpoint
3. REST Sender Adapter receives order data
4. Data converts to internal XML format
5. Field mappings applied
6. Transformed data sent to ERP system via Receiver Adapter
7. Confirmation returned to Shopify
```

### Example 2: SOAP Service Polling Integration

**Scenario**: Poll SAP for updated customer records

**1. Create SOAP Sender Adapter:**
```yaml
Name: "SAP Customer Poller"
Type: SOAP
Direction: Sender
endpointUrl: "https://sap.company.com/soap/CustomerService"
WSDL: "https://sap.company.com/soap/CustomerService?wsdl"
Operation: "GetModifiedCustomers"
Polling:
  Enabled: true
  Interval: 600000  # 10 minutes
Parameters:
  LastSyncDate: ${lastPollTimestamp}
```

**2. Operation Flow:**
```
1. Every 10 minutes, adapter calls SOAP service
2. Sends GetModifiedCustomers request with last sync timestamp
3. SAP returns customers modified since last poll
4. SOAP envelope parsed, data extracted
5. Each customer record processed through integration flow
6. Updates applied to CRM system
7. Last poll timestamp updated for next cycle
```

### Example 3: HTTP Hybrid Mode Integration

**Scenario**: Inventory updates via both webhooks and polling

**1. Create HTTP Sender Adapter:**
```yaml
Name: "Inventory Update Handler"
Type: HTTP
Direction: Sender
endpointUrl: "https://warehouse.api.com/inventory/changes"
Polling:
  Enabled: true
  Interval: 1800000  # 30 minutes
Authentication:
  Type: API Key
  Header: X-API-Key
  Key: ${env.WAREHOUSE_API_KEY}
```

**2. Generated Endpoint:**
```
http://integration.company.com/api/inbound/webhook/inventory-update-handler-abc123
```

**3. Operation Flow:**

**Via Webhook (Real-time critical updates):**
```
1. Warehouse system detects critical stock change
2. Sends immediate POST to webhook endpoint
3. Adapter processes urgent update
4. Triggers immediate sync to connected systems
```

**Via Polling (Batch updates):**
```
1. Every 30 minutes, adapter polls warehouse API
2. Retrieves all changes since last poll
3. Processes batch updates
4. Ensures no updates missed if webhooks fail
```

## Troubleshooting

### Common Issues and Solutions

#### 1. External System Can't Reach Webhook Endpoint

**Symptom**: External system reports connection errors

**Checks:**
- Verify firewall rules allow inbound connections
- Confirm endpoint URL includes correct protocol (http/https)
- Check if authentication headers are properly set
- Validate SSL certificates for HTTPS endpoints

**Solution Example:**
```bash
# Test endpoint accessibility
curl -X POST http://your-server:8080/api/inbound/webhook/your-adapter-id \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your-token" \
  -d '{"test": "data"}'
```

#### 2. Polling Not Working

**Symptom**: No data being fetched from external system

**Checks:**
- Verify `polling.enabled = true`
- Confirm `endpointUrl` points to correct external API
- Check authentication credentials
- Review adapter logs for connection errors

**Debug Configuration:**
```yaml
Logging:
  Level: DEBUG
  Include Headers: true
  Log Request/Response: true
```

#### 3. Authentication Failures

**Symptom**: 401/403 errors in logs

**Solutions by Type:**

**Bearer Token:**
```yaml
# Check token format
Authorization: Bearer ${env.TOKEN}  # Correct
Authorization: ${env.TOKEN}         # Incorrect - missing "Bearer"
```

**API Key:**
```yaml
# Verify header name matches external system
Header Name: X-API-Key      # Common
Header Name: api-key        # Alternative
Header Name: Authorization  # Some systems
```

**OAuth2:**
```yaml
# Ensure token refresh is configured
Token URL: "https://auth.server.com/token"
Refresh Token: ${env.REFRESH_TOKEN}
Auto Refresh: true
```

#### 4. Data Format Issues

**Symptom**: Adapter receives data but processing fails

**Common Fixes:**
```yaml
# Ensure Content-Type matches actual data
Content-Type: application/json   # For JSON
Content-Type: application/xml    # For XML
Content-Type: text/plain        # For plain text

# Configure charset if needed
Content-Type: application/json; charset=UTF-8
```

### Monitoring and Logs

#### Key Metrics to Monitor:
1. **Webhook Endpoints:**
   - Request count per minute
   - Response time average
   - Error rate (4xx, 5xx responses)
   - Payload size distribution

2. **Polling Operations:**
   - Poll success rate
   - Records fetched per poll
   - Poll duration
   - Time since last successful poll

#### Log Locations:
```
/logs/adapters/http-sender-{adapterId}.log
/logs/adapters/webhook-requests.log
/logs/adapters/polling-operations.log
```

#### Useful Log Queries:
```bash
# Check recent webhook requests
grep "webhook/your-adapter-id" webhook-requests.log | tail -50

# Monitor polling cycles
grep "Polling initiated" http-sender-your-adapter-id.log

# Track authentication errors
grep -E "(401|403|Unauthorized)" http-sender-*.log
```

## Best Practices

### 1. Security
- Always use HTTPS in production
- Implement webhook signature validation
- Rotate API keys/tokens regularly
- Use environment variables for credentials

### 2. Reliability
- Enable polling as backup for webhook-only integrations
- Implement idempotency for duplicate message handling
- Set appropriate timeout values
- Configure retry policies

### 3. Performance
- Use pagination for large data sets
- Implement incremental polling (last modified timestamps)
- Set reasonable polling intervals
- Monitor and adjust rate limits

### 4. Maintenance
- Document endpoint URLs and authentication methods
- Keep WSDL/OpenAPI specifications updated
- Monitor deprecated API versions
- Plan for endpoint URL changes

## Summary

The key understanding for HTTP-type sender adapters:

1. **User-configured `endpointUrl`** = External system to poll FROM
2. **System-generated endpoint** = Where external systems send data TO
3. Both can work together in hybrid mode
4. The adapter ID in the generated URL ensures proper routing
5. All HTTP-type adapters (HTTP, HTTPS, REST, SOAP) follow this same pattern

This architecture provides flexibility for both push (webhook) and pull (polling) integration patterns while maintaining security and consistency across the platform.